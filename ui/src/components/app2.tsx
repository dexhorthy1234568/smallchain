import { useEffect, useState } from "react";
import "@/App.css";
import { useSWRFetch } from "@/lib/utils.ts";
import { ChatCompletionMessageToolCall } from "openai/resources/chat/completions";

/**
 * fork of openAI type with any role allowed
 */
export type ChatCompletionMessageWithAnyRole = {
    /**
   * The contents of the message.
   */
    content: string | null;

    /**
     * The refusal message generated by the model.
     */
    refusal: string | null;

    /**
     * The role of the author of this message.
     */
    role: "user" | "assistant" | "tool" | "system"

    /**
     * The tool calls generated by the model, such as function calls.
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
}

export type ClientChain = {
    id: number
    // agent name
    agent_name?: string
    messages: (ChatCompletionMessageWithAnyRole)[]
    created_at: string
    updated_at: string
    status:
    | "awaiting_llm_processing"
    | "llm_processing"
    | "stop_awaiting_user"
    | "awaiting_function_call"
}

export type Agent = {
    id?: number
    system_prompt: string
    name: string
    tools: any[]
    delegation_tool?: {
        description?: string
    }
}

export function App2() {
    let { data, mutate } = useSWRFetch<ClientChain[]>("/api/chains")
    const [newThread, setNewThread] = useState("");

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!newThread.trim()) return;

        const response = await fetch("/api/chains", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                agent_name: "project_manager",
                userMessage: newThread,
            }),
        });

        if (response.ok) {
            setNewThread("");
            mutate();
        }
    };

    useEffect(() => {
        const interval = setInterval(() => {
            mutate()
        }, 200)
        return () => clearInterval(interval)
    }, [])

    if (!data) {
        return <div>Loading...</div>
    }

    // Sort the data by the created_at timestamp in descending order
    data = data.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

    const chains = data;
    const divs = chains.map((chain: ClientChain) => {
        return (
            <div className="flex flex-col gap-4 items-start justify-start align-start" >
                {
                    chain.messages.map((message: ChatCompletionMessageWithAnyRole) => {
                        const className = "p-1 rounded-md w-full " + (
                            message.role === "user" ? "bg-cyan-400 text-gray-900 border-2 " :
                                message.role === "assistant" ? (message.tool_calls ? "bg-violet-500" : "bg-violet-400") + " border-2 " :
                                    message.role === "tool" ? "bg-white text-gray-800 border-2 " :
                                        message.role === "system" ?
                                            "text-gray-50 bg-gray-700" : "text-white bg-gray-900"
                        )
                        return (
                            message.tool_calls ? (
                                message.tool_calls.map((toolCall: ChatCompletionMessageToolCall) => (
                                    <AssistantToolCallNode key={toolCall.id} toolCall={toolCall} />
                                ))
                            ) : (
                                <div key={message.content} className={className}>
                                    <div className="role-label"><b>{message.role}</b></div>
                                    <div className="p-1">{message.content}</div>
                                </div>
                            )
                        );
                    })
                }
                {chain.status === "stop_awaiting_user" && (
                    <div className='flex flex-col w-full items-center'>
                        <div className="text-xs bg-gray-600 text-white rounded-md p-2">
                            {chain.status}
                        </div>
                    </div>
                )}
            </div>
        );
    });

    return (
        <div className="bg-gray-900 min-h-screen text-white p-4 w-screen">
            <form onSubmit={handleSubmit} className="mb-4 flex flex-row gap-2">
                <input
                    type="text"
                    value={newThread}
                    onChange={(e) => setNewThread(e.target.value)}
                    onKeyDown={(e) => {
                        if (e.key === "Enter") {
                            handleSubmit(e)
                        }
                    }}
                    className="p-2 rounded-md w-full text-gray-50"
                    placeholder="Start a new thread..."
                />
                <button type="submit"
                    className="bg-violet-400 border-2 p-2 rounded-md w-full text-gray-900"
                >
                    Submit
                </button>
            </form>
            <div className="flex flex-row gap-4 items-start justify-start align-start">{divs}</div>
        </div>
    );
}

const AssistantToolCallNode = ({ toolCall }: { toolCall: ChatCompletionMessageToolCall }) => {
    const className = "p-0.5 rounded-md w-full bg-violet-400 border-2 "
    return (
        <div key={toolCall.id} className={className}>
            <div className=""><b>assistant</b></div>
            <div className="p-1">
                <pre className="text-white">{`${toolCall.function.name}(${toolCall.function.arguments})`}</pre>
            </div>
        </div>
    )

}